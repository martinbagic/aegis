"""Data recorder

Records data generated by the simulation.

When thinking about recording additional data, consider that there are three recording methods:
    I. Snapshots (record data from the population at a specific stage)
    II. Flushes (collect data over time then flush)
    III. One-time records
"""

import pandas as pd
import numpy as np
import json
import time
import copy
import psutil
import subprocess
import logging
import pathlib
import shutil

from aegis.hermes import hermes
from aegis.modules.recording.popgenstats import PopgenStats
from aegis.constants import VALID_CAUSES_OF_DEATH


class Recorder:
    def __init__(self, custom_config_path, overwrite):
        self.progress_path = None  # TODO

        self.time_start = time.time()

        self.output_path = self.initialize_output_directory(custom_config_path=custom_config_path, overwrite=overwrite)
        self.paths = {
            "BASE_DIR": self.output_path,
            "snapshots_genotypes": self.output_path / "snapshots" / "genotypes",
            "snapshots_phenotypes": self.output_path / "snapshots" / "phenotypes",
            "snapshots_demography": self.output_path / "snapshots" / "demography",
            "visor": self.output_path / "visor",
            "visor_spectra": self.output_path / "visor" / "spectra",
            "input_summary": self.output_path,
            "output_summary": self.output_path,
            "pickles": self.output_path / "pickles",
            "popgen": self.output_path / "popgen",
            "phenomap": self.output_path,
            "te": self.output_path / "te",
        }

        for path in self.paths.values():
            path.mkdir(exist_ok=True, parents=True)

        # Initialize collection
        self._collection = {
            "age_at_birth": [0] * hermes.parameters.MAX_LIFESPAN,
            "additive_age_structure": [0] * hermes.parameters.MAX_LIFESPAN,
        }

        self._collection.update(
            {f"age_at_{causeofdeath}": [0] * hermes.parameters.MAX_LIFESPAN for causeofdeath in VALID_CAUSES_OF_DEATH}
        )

        self.collection = copy.deepcopy(self._collection)

        # Needed for output summary
        self.extinct = False

        # Memory utilization
        self.memory_use = []
        self.psutil_process = psutil.Process()

        # PopgenStats
        self.popgenstats = PopgenStats()

        # other
        self.te_record_number = 0

        # Add headers
        for key in self._collection.keys():
            with open(self.paths["visor_spectra"] / f"{key}.csv", "ab") as f:
                array = np.arange(hermes.parameters.MAX_LIFESPAN)
                np.savetxt(f, [array], delimiter=",", fmt="%i")

        with open(self.paths["visor"] / "genotypes.csv", "ab") as f:
            array = np.arange(
                hermes.modules.architect.architecture.get_number_of_bits()
            )  # (ploidy, length, bits_per_locus)
            np.savetxt(f, [array], delimiter=",", fmt="%i")

        with open(self.paths["visor"] / "phenotypes.csv", "ab") as f:
            array = np.arange(
                hermes.modules.architect.architecture.get_number_of_phenotypic_values()
            )  # number of phenotypic values
            np.savetxt(f, [array], delimiter=",", fmt="%i")

        if hasattr(hermes.modules.architect.architecture, "phenomap"):
            self.record_phenomap(hermes.modules.architect.architecture.phenomap.phenolist)

    @staticmethod
    def initialize_output_directory(custom_config_path, overwrite) -> pathlib.Path:
        output_path = custom_config_path.parent / custom_config_path.stem  # remove .yml
        is_occupied = output_path.exists() and output_path.is_dir()
        if is_occupied:
            if overwrite:
                shutil.rmtree(output_path)
            else:
                raise Exception(f"{output_path} already exists. To overwrite, add flag --overwrite or -o.")
        return output_path

    @staticmethod
    def get_dhm(timediff):
        """Format time in a human-readable format."""
        d = int(timediff / 86400)
        timediff %= 86400
        h = int(timediff / 3600)
        timediff %= 3600
        m = int(timediff / 60)
        return f"{d}`{h:02}:{m:02}"

    @staticmethod
    def skip(rate) -> bool:
        """Should you skip an action performed at a certain rate"""

        # Skip if rate deactivated
        if rate <= 0:
            return True

        # Do not skip first stage
        if hermes.stage == 1:
            return False

        # Skip unless stage is divisible by rate
        return hermes.stage % rate > 0

    def _log_progress(self, popsize="?"):
        """Record some information about the time and speed of simulation."""

        if Recorder.skip(hermes.parameters.LOGGING_RATE):
            return

        stage = hermes.get_stage()

        logging.info("%8s / %s / N=%s", stage, hermes.parameters.STAGES_PER_SIMULATION, popsize)

        # Get time estimations
        time_diff = time.time() - self.time_start

        seconds_per_100 = time_diff / stage * 100
        eta = (hermes.parameters.STAGES_PER_SIMULATION - stage) / 100 * seconds_per_100

        stages_per_min = int(stage / (time_diff / 60))

        runtime = Recorder.get_dhm(time_diff)
        time_per_1M = Recorder.get_dhm(time_diff / stage * 1000000)
        eta = Recorder.get_dhm(eta)

        # Save time estimations
        content = (stage, eta, time_per_1M, runtime, stages_per_min, popsize)
        with open(self.output_path / "progress.log", "ab") as f:
            np.savetxt(f, [content], fmt="%-10s", delimiter="| ")

    # ===============================
    # RECORDING METHOD I. (snapshots)
    # ===============================

    def record_memory_use(self):
        # TODO refine
        memory_use_ = self.psutil_process.memory_info()[0] / float(2**20)
        self.memory_use.append(memory_use_)
        if len(self.memory_use) > 1000:
            self.memory_use.pop(0)

    def record_visor(self, population):
        """Record data that is needed by visor."""
        if Recorder.skip(hermes.parameters.VISOR_RATE) or len(population) == 0:
            return

        # genotypes.csv | Record allele frequency
        with open(self.paths["visor"] / "genotypes.csv", "ab") as f:
            array = population.genomes.flatten().mean(0)
            np.savetxt(f, [array], delimiter=",", fmt="%1.3e")

        # phenotypes.csv | Record median phenotype
        with open(self.paths["visor"] / "phenotypes.csv", "ab") as f:
            array = np.median(population.phenotypes, 0)
            np.savetxt(f, [array], delimiter=",", fmt="%1.3e")

        self.flush()

    def record_snapshots(self, population):
        """Record demographic, genetic and phenotypic data from the current population."""
        if Recorder.skip(hermes.parameters.SNAPSHOT_RATE) or len(population) == 0:
            return

        stage = hermes.get_stage()

        logging.debug(f"Snapshots recorded at stage {stage}")

        # genotypes
        df_gen = pd.DataFrame(np.array(population.genomes.flatten()))
        df_gen.reset_index(drop=True, inplace=True)
        df_gen.columns = [str(c) for c in df_gen.columns]
        df_gen.to_feather(self.paths["snapshots_genotypes"] / f"{stage}.feather")

        # phenotypes
        df_phe = pd.DataFrame(np.array(population.phenotypes))
        df_phe.reset_index(drop=True, inplace=True)
        df_phe.columns = [str(c) for c in df_phe.columns]
        df_phe.to_feather(self.paths["snapshots_phenotypes"] / f"{stage}.feather")

        # demography
        dem_attrs = ["ages", "births", "birthdays"]
        demo = {attr: getattr(population, attr) for attr in dem_attrs}
        df_dem = pd.DataFrame(demo, columns=dem_attrs)
        df_dem.reset_index(drop=True, inplace=True)
        df_dem.to_feather(self.paths["snapshots_demography"] / f"{stage}.feather")

    def record_popgenstats(self, genomes, mutation_rates):
        """Record population size in popgenstats, and record popgen statistics."""
        self.popgenstats.record_pop_size_history(genomes.array)

        if Recorder.skip(hermes.parameters.POPGENSTATS_RATE) or len(genomes) == 0:
            return

        self.popgenstats.calc(genomes.array, mutation_rates)

        # Record simple statistics
        array = list(self.popgenstats.emit_simple().values())
        if None in array:
            return

        with open(self.paths["popgen"] / "simple.csv", "ab") as f:
            np.savetxt(f, [array], delimiter=",", fmt="%1.3e")

        # Record complex statistics
        complex_statistics = self.popgenstats.emit_complex()
        for key, array in complex_statistics.items():
            with open(self.paths["popgen"] / f"{key}.csv", "ab") as f:
                np.savetxt(f, [array], delimiter=",", fmt="%1.3e")

    def record_pickle(self, population):

        stage = hermes.get_stage()

        if (
            Recorder.skip(hermes.parameters.PICKLE_RATE) and not stage == 1
        ):  # Also records the pickle before the first stage
            return

        logging.debug(f"pickle recorded at stage {stage}")

        pickle_path = self.paths["pickles"] / str(stage)
        population.save_pickle_to(pickle_path)

    # ==============================
    # RECORDING METHOD II. (flushes)
    # ==============================

    def collect(self, key, ages):
        """Add data into memory which will be recorded later."""
        self.collection[key] += np.bincount(ages, minlength=hermes.parameters.MAX_LIFESPAN)

    def flush(self):
        """Record data that has been collected over time."""
        # spectra/*.csv | Age distribution of various subpopulations (e.g. population that died of genetic causes)

        for key, val in self.collection.items():
            with open(self.paths["visor_spectra"] / f"{key}.csv", "ab") as f:
                array = np.array(val)
                np.savetxt(f, [array], delimiter=",", fmt="%i")

        # Reinitialize the collection
        self.collection = copy.deepcopy(self._collection)

    # =================================
    # RECORDING METHOD III. (record once)
    # =================================

    def record_phenomap(self, phenolist):
        if phenolist:
            pd.DataFrame(phenolist).to_csv(
                self.paths["phenomap"] / "phenomap.csv", index=None, header=["bit", "trait", "age", "weight"]
            )
        else:
            logging.info("Phenomap is empty")

    @staticmethod
    def get_folder_size_with_du(folder_path):
        result = subprocess.run(["du", "-sh", folder_path], stdout=subprocess.PIPE, text=True)
        return result.stdout.split()[0]

    def record_output_summary(self):
        try:
            storage_use = self.get_folder_size_with_du(self.output_path)
        except:
            storage_use = ""

        summary = {
            "extinct": self.extinct,
            "random_seed": hermes.random_seed,
            "time_start": self.time_start,
            "runtime": time.time() - self.time_start,
            "jupyter_path": str(self.output_path.absolute()),
            "memory_use": np.median(self.memory_use),
            "storage_use": storage_use,
        }
        with open(self.paths["output_summary"] / "output_summary.json", "w") as f:
            json.dump(summary, f, indent=4)

    def record_input_summary(self):
        summary = {
            # "extinct": extinct,
            "random_seed": hermes.random_seed,
            "time_start": self.time_start,
            # "time_end": time.time(),
            "jupyter_path": str(self.output_path.absolute()),
        }
        with open(self.paths["input_summary"] / "input_summary.json", "w") as f:
            json.dump(summary, f, indent=4)

    # =================================
    # RECORDING METHOD IV. (other)
    # =================================

    def record_TE(self, T, e):
        """
        Record deaths.
        T .. time / duration (ages)
        E .. event observed (0/alive or 1/dead)

        ###

        To fit this data using lifelines, use this script as inspiration:
            from lifelines import KaplanMeierFitter
            kmf = KaplanMeierFitter()
            te = pd.read_csv("/path/to/te/1.csv")
            kmf.fit(te["T"], te["E"])
            kmf.survival_function_.plot()

        You can compare this to observed survivorship curves:
            analyzer.get_total_survivorship(container).plot()

        """

        assert e in ("alive", "dead")

        stage = hermes.get_stage()

        if (stage % hermes.parameters.TE_RATE) == 0 or stage == 1:
            # open new file and add header
            with open(self.paths["te"] / f"{self.te_record_number}.csv", "w") as file_:
                array = ["T", "E"]
                np.savetxt(file_, [array], delimiter=",", fmt="%s")

        elif ((stage % hermes.parameters.TE_RATE) < hermes.parameters.TE_DURATION) and e == "dead":
            # record deaths
            E = np.repeat(1, len(T))
            data = np.array([T, E]).T
            with open(self.paths["te"] / f"{self.te_record_number}.csv", "ab") as file_:
                np.savetxt(file_, data, delimiter=",", fmt="%i")

        elif (
            ((stage % hermes.parameters.TE_RATE) == hermes.parameters.TE_DURATION)
            or stage == hermes.parameters.STAGES_PER_SIMULATION
        ) and e == "alive":
            # flush
            logging.debug(f"Data for survival analysis (T,E) flushed at stage {stage}")
            E = np.repeat(0, len(T))
            data = np.array([T, E]).T
            with open(self.paths["te"] / f"{self.te_record_number}.csv", "ab") as file_:
                np.savetxt(file_, data, delimiter=",", fmt="%i")

            self.te_record_number += 1
